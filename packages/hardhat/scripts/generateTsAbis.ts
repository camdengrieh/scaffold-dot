/**
 * DON'T MODIFY OR DELETE THIS SCRIPT (unless you know what you're doing)
 *
 * This script generates the file containing the contracts Abi definitions.
 * These definitions are used to derive the types needed in the custom scaffold-eth hooks, for example.
 * This script should run as the last deploy script.
 */

import * as fs from "fs";
import prettier from "prettier";
import { DeployFunction } from "hardhat-deploy/types";

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-DOT.
 * You should not edit it manually or your changes might be overwritten.
 */
`;

const DEPLOYMENTS_DIR = "./deployments";
const ARTIFACTS_DIR = "./artifacts";

function getDirectories(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
}

function getContractNames(path: string) {
  return fs
    .readdirSync(path, { withFileTypes: true })
    .filter(dirent => dirent.isFile() && dirent.name.endsWith(".json"))
    .map(dirent => dirent.name.split(".")[0]);
}

function getActualSourcesForContract(sources: Record<string, any>, contractName: string) {
  for (const sourcePath of Object.keys(sources)) {
    const sourceName = sourcePath.split("/").pop()?.split(".sol")[0];
    if (sourceName === contractName) {
      const sourceData = sources[sourcePath];

      // Check if content exists and is a string
      if (sourceData && sourceData.content && typeof sourceData.content === "string") {
        const contractContent = sourceData.content;
        const regex = /contract\s+(\w+)\s+is\s+([^{}]+)\{/;
        const match = contractContent.match(regex);

        if (match) {
          const inheritancePart = match[2];
          // Split the inherited contracts by commas to get the list of inherited contracts
          const inheritedContracts = inheritancePart.split(",").map((contract: string) => `${contract.trim()}.sol`);
          return inheritedContracts;
        }
      }
      return [];
    }
  }
  return [];
}

function getInheritedFunctions(sources: Record<string, any>, contractName: string) {
  try {
    const actualSources = getActualSourcesForContract(sources, contractName);
    const inheritedFunctions = {} as Record<string, any>;

    for (const sourceContractName of actualSources) {
      const sourcePath = Object.keys(sources).find(key => key.includes(`/${sourceContractName}`));
      if (sourcePath) {
        const sourceName = sourcePath?.split("/").pop()?.split(".sol")[0];
        try {
          const artifactPath = `${ARTIFACTS_DIR}/${sourcePath}/${sourceName}.json`;
          if (fs.existsSync(artifactPath)) {
            const { abi } = JSON.parse(fs.readFileSync(artifactPath).toString());
            for (const functionAbi of abi) {
              if (functionAbi.type === "function") {
                inheritedFunctions[functionAbi.name] = sourcePath;
              }
            }
          }
        } catch (artifactError) {
          // Skip if artifact file doesn't exist or can't be parsed
          const errorMessage = artifactError instanceof Error ? artifactError.message : String(artifactError);
          console.warn(`Warning: Could not read artifact for ${sourceName}:`, errorMessage);
        }
      }
    }

    return inheritedFunctions;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.warn(`Warning: Could not process inherited functions for ${contractName}:`, errorMessage);
    return {};
  }
}

function getContractDataFromDeployments() {
  if (!fs.existsSync(DEPLOYMENTS_DIR)) {
    throw Error("At least one other deployment script should exist to generate an actual contract.");
  }
  const output = {} as Record<string, any>;
  for (const chainName of getDirectories(DEPLOYMENTS_DIR)) {
    const chainId = fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/.chainId`).toString();
    const contracts = {} as Record<string, any>;
    for (const contractName of getContractNames(`${DEPLOYMENTS_DIR}/${chainName}`)) {
      try {
        const deploymentData = JSON.parse(
          fs.readFileSync(`${DEPLOYMENTS_DIR}/${chainName}/${contractName}.json`).toString(),
        );
        const { abi, address, metadata } = deploymentData;

        let inheritedFunctions = {};
        if (metadata) {
          try {
            // Handle both cases: metadata as string (old format) or object (new format)
            const metadataObj = typeof metadata === "string" ? JSON.parse(metadata) : metadata;

            // Check if we have solc_metadata and it's a string that needs parsing
            if (metadataObj.solc_metadata && typeof metadataObj.solc_metadata === "string") {
              const solcMetadata = JSON.parse(metadataObj.solc_metadata);
              if (solcMetadata.sources) {
                inheritedFunctions = getInheritedFunctions(solcMetadata.sources, contractName);
              }
            } else if (metadataObj.sources) {
              // Direct sources object
              inheritedFunctions = getInheritedFunctions(metadataObj.sources, contractName);
            }
          } catch (metadataError) {
            console.warn(`Warning: Could not parse metadata for contract ${contractName}:`, metadataError);
            inheritedFunctions = {};
          }
        }

        contracts[contractName] = { address, abi, inheritedFunctions };
      } catch (error) {
        console.error(`Error processing contract ${contractName}:`, error);
        throw error;
      }
    }
    output[chainId] = contracts;
  }
  return output;
}

/**
 * Generates the TypeScript contract definition file based on the json output of the contract deployment scripts
 * This script should be run last.
 */
const generateTsAbis: DeployFunction = async function () {
  const TARGET_DIR = "../nextjs/contracts/";
  const allContractsData = getContractDataFromDeployments();

  const fileContent = Object.entries(allContractsData).reduce((content, [chainId, chainConfig]) => {
    return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(chainConfig, null, 2)},`;
  }, "");

  if (!fs.existsSync(TARGET_DIR)) {
    fs.mkdirSync(TARGET_DIR);
  }
  fs.writeFileSync(
    `${TARGET_DIR}deployedContracts.ts`,
    await prettier.format(
      `${generatedContractComment} import { GenericContractsDeclaration } from "~~/utils/scaffold-eth/contract"; \n\n
 const deployedContracts = {${fileContent}} as const; \n\n export default deployedContracts satisfies GenericContractsDeclaration`,
      {
        parser: "typescript",
      },
    ),
  );

  console.log(`üìù Updated TypeScript contract definition file on ${TARGET_DIR}deployedContracts.ts`);
};

export default generateTsAbis;
